[{"authors":["puneet"],"categories":null,"content":"Hi! I am a first year PhD Computer Science student at the University of British Columbia. I am a member of the NSS Lab, and am supervised by Prof. Margo Seltzer.\nPreviously, I worked with Prof. Ivan Beschastnikh for my masters degree. My thesis explored trusted execution for cross-platform data privacy. Prior to that I worked at NetApp Inc., making tools and utilities to make Linux hosts work seamlessly with NetApp\u0026rsquo;s Data ONTAP.\n","date":1526022000,"expirydate":-62135596800,"kind":"taxonomy","lang":"en","lastmod":1526022000,"objectID":"a1dcfa7f6b8363d8b5e4568999cb49ee","permalink":"//localhost:1313/authors/puneet/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/authors/puneet/","section":"authors","summary":"Hi! I am a first year PhD Computer Science student at the University of British Columbia. I am a member of the NSS Lab, and am supervised by Prof. Margo Seltzer.\nPreviously, I worked with Prof. Ivan Beschastnikh for my masters degree. My thesis explored trusted execution for cross-platform data privacy. Prior to that I worked at NetApp Inc., making tools and utilities to make Linux hosts work seamlessly with NetApp\u0026rsquo;s Data ONTAP.","tags":null,"title":"Puneet Mehrotra","type":"authors"},{"authors":null,"categories":null,"content":"Verifying systems code is hard because of concurrency and inherent complexity of the code. Understanding the invariants and other behavioral and performance characteristics of a distributed systems is challenging because multiple nodes communicate and coordinate together towards the task of performing a computation.\nVerification methods and tools implicitly assume that the code to be verified is deterministic. That is users of the software will provide relevant inputs, and by verifying program behavior using all possible values of that input, a given verification methodology can draw inferences about a system.\nIn the case of distributed software, the assumption of implicit determinism is void. Network software typically works in collaboration with other compute nodes in order to fulfill the required functionality. For example, in a peer-to-peer system, peers detect node failures using heartbeat messages. Service Oriented Architecture is another example where a number of services communicate using a complex chain of RPC calls. Since the underlying communication takes place in the form of raw packets, often the program behavior can potentially change if the packets are received out of order or packets are lost in the network. Therefore, in this context, both the incoming data and the send/receive order can potentially impact program behavior and consequently increase the complexity of verification methodology.\nAn additional challenge is attributed to concurrency. Most modern systems use multi-threading to achieve better performance. In such a case, the outcome of a program is a function of how individual threads are interleaved together. Reasoning about such interleaved execution paths is hard and adds another layer of complexity to the process of verification.\nGiven the above challenges, we were curious about the usability of existing symbolic execution tools for verification of system software. In particular, we were interested in understanding how easy it is to use symbolic execution to verify systems software that interacts with the networking stack. We, therefore, analyzed Snort using the popular symbolic execution engine named KLEE. We documented the challenges that we encountered along the way. We also looked at recent research papers to understand how they approach the problem of verifying such code.\nPDF\n","date":1545342660,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1545342660,"objectID":"389b44086699c7c95bfe146825d548da","permalink":"//localhost:1313/project/formal_verification/","publishdate":"2018-12-20T13:51:00-08:00","relpermalink":"/project/formal_verification/","section":"project","summary":"Understanding usability of KLEE by trying to analyse a large Intrusion Detection System","tags":["Formal Verification","systems","software engineering"],"title":"Analysing Snort with KLEE","type":"project"},{"authors":null,"categories":null,"content":"Revelio is a tool that statically analyses Python code for known vulnerabilities. The tool provides a IDE plugin for Sublime for highlighting vulnerabilities as well as a command-line interfaces that provides the following features:\n Detection of vulnerable functions Detection of dependencies with vulnerabilities Automatic replacement of vulnerable function with safe alternatives Automatically running tests Detecting and updating outdated dependencies Downloading and analyzing of GitHub repositories as well as local files Automatically creating pull-requests to GitHub repositories to fix vulnerable functions  Currently, Revelio is just a prototype which was developed as part of a Software Engineering course.\nInstallation  Download the source code of the tool Install all requirements: pip install -r requirements.txt  Configuration In order for the tool to access the Github API the Github username and password need to be set as environment variables: export GITHUB_USER=\u0026lt;user\u0026gt; and export GITHUB_PASSWORD=\u0026lt;password\u0026gt;.\nUsage To analyze a local repository the path must be provided:\npython cli.py --path \u0026quot;/local/path\u0026quot;\nTo analyze a remote repository on github the URL to the repository must be provided:\npython cli.py --url \u0026quot;\u0026lt;URL\u0026gt;\u0026quot;\nTo access the github repository the API access token needs to be set (see Configuration).\nCollected Data For analyzed github repositories metrics will be collected in /tmp in metrics.json.\nDocker To build the container:\ndocker build -t 507 .\nTo run the container:\ndocker run --name 507 -v /tmp/dock:/tmp -e GITHUB_USER=\u0026quot;username\u0026quot; -e GITHUB_PASSWORD=\u0026quot;password\u0026quot; 507 \u0026amp; \nTo remove the container:\ndocker rm 507\nSupported Testing Frameworks The space of Python testing is very fragmented, and there is not universal method of writing testcases. To make the process simple and extensible, we use the tox test framework, that simplifies the execution of the tests. We look at the standard locations to discover tests, and support the standard testing mechanisms. Here are our assumptions:\n  The tests are placed in the ${project}/test[s] directory\n  The requirements necessary are present in a requirements.txt file. Often developers specify multiple versions of this file. We look for all files in the repository that have a name starting with \u0026lsquo;requirements\u0026rsquo; to include for installation in the virtualenv.\n  The supported methods of testing the project are: setup.py with a test recipe, py.tests, nosetests, and plain old unittests.\n  Known issues and fixes When running tox in the macOS terminal the following error might ocurr:\nunknown locale: UTF-8 in Python\n","date":1527327045,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1527327045,"objectID":"5baf35d955a49003f5750a7a82f9ee0f","permalink":"//localhost:1313/project/revelio/","publishdate":"2018-05-26T02:30:45-07:00","relpermalink":"/project/revelio/","section":"project","summary":"A tool for doing static analysis of Python code for known vulnerabilities","tags":["Software Engineering"],"title":"Revelio","type":"project"},{"authors":null,"categories":null,"content":"Security of data is tightly coupled to its access policy. However, in practice, a data owner has control of his data\u0026rsquo;s access policies only as far as the boundaries of his own systems. In this paper, we introduce graduated access control, which provides mobile, programmable, and dynamically-resolving policies for access control that extends a data owner\u0026rsquo;s policies across system boundaries. We realize this through a novel data-centric abstraction called trusted capsules and its associated system, the trusted data monitor.\nA trusted capsule couples data and policy into a single mobile unit. A capsule is backwards-compatible and is indistinguishable from a regular file to applications. In coordination with the trusted data monitor a capsule provides data integrity and confidentiality on remote devices, strong authentication to a trusted capsule service, and supports nuanced and dynamic access control decisions on remote systems. We implemented our data monitor using ARM TrustZone.\nWe show that graduated access control can express novel and useful real world policies, such as revocation, remote monitoring, and risk-adaptable disclosure. We illustrate trusted capsules for different file formats, including JPEG, FODT, and PDF. We also show compatibility with unmodified applications, such as LibreOffice Writer, Evince, and VLC.\n","date":1527231600,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1527231600,"objectID":"535d24f6b95725ecf701f6f4fc105dd2","permalink":"//localhost:1313/project/trusted_capsules/","publishdate":"2018-05-25T00:00:00-07:00","relpermalink":"/project/trusted_capsules/","section":"project","summary":"ARM TrustZone backed data privacy on remote devices","tags":["Security"],"title":"Trusted Capsules","type":"project"},{"authors":["Puneet Mehrotra","Amanda Carbonari","Peter Chen","Ivan Beschastnikh","Andrew Warfield"],"categories":null,"content":" Click on the Slides button above to view the built-in slides feature.   -- ","date":1526022000,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1526022000,"objectID":"3fcbdbb4952f31357efb01a9f9a606c4","permalink":"//localhost:1313/talk/tc/","publishdate":"2018-05-11T00:00:00-07:00","relpermalink":"/talk/tc/","section":"talk","summary":" Click on the Slides button above to view the built-in slides feature.   -- ","tags":[],"title":"Cross-platform Data Integrity and Confidentiality with Graduated Access Control","type":"talk"}]